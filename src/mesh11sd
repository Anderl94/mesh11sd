#!/bin/sh
# Copyright (C) BlueWave Projects and Services 2015-2024
#
#	This software is released under the GNU General Public License version 3 or any later version.
#	This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation,
#	either version 3 of the License, or (at your option) any later version.
#
#	This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#	See the GNU General Public License for more details.
#
#	To obtain a copy of the GNU General Public License, see <https://www.gnu.org/licenses/>.
#
# mesh11sd daemon
#
version="3.0.0beta"
fixup1=0

get_mesh_iflist () {
	iflist=""
	all_ifcs=$(iw dev | awk -F "Interface " '$2>0{printf "%s " $2}')

	for iface in $all_ifcs; do
		iftype=$(iw dev $iface info | grep "type" | awk '{printf "%s", $2}')

		if [ "$iftype" = "mesh" ]; then
			iflist="$iflist $iface"
		fi
	done
}

check_mesh_phantom () {
	nodelist=$(iw dev $iface mpath dump | awk '{printf "%s,%s ", $1, $2}')

	debugtype="debug"
	syslogmessage="nodelist [$nodelist]"
	write_to_syslog

	for node in $nodelist; do
		phantom=$(echo "$node" | awk -F"," '$2 == "00:00:00:00:00:00" {printf $1 }')

		if [ ! -z "$phantom" ]; then
			debugtype="warn"
			syslogmessage="Phantom meshnode detected [$phantom] - deleting"
			write_to_syslog
			iw dev $iface mpath del $phantom
		fi
	done
}

get_params () {
	params=$(iw dev $iface mesh_param dump 2> /dev/null)

	if [ "$?" != 0 ]; then
		buffer="/tmp/"$(date | sha256sum | awk '{printf $1}')
		param_list=$(iw dev $iface get mesh_param 2> /dev/null | grep " - " | awk -F" - " '{printf "%s ", $2}')
		params=""


		for param in $param_list; do
			paramval=$(iw dev $iface get mesh_param $param 2> /dev/null)
			if [ "$?" -eq 0 ]; then
				paramline="$param = $paramval"
				echo "$paramline" >> $buffer
			fi
		done



		if [ -e "$buffer" ]; then
			params=$(cat $buffer)
			rm "$buffer"
		fi
	fi
}

check_mesh_params () {

	for param in $params; do

		conf=$(uci get $uciname.$param 2> /dev/null)

		if [ -z "$conf" ]; then
			continue
		fi

		param_value=$(iw dev $iface get mesh_param $param | awk '{printf "%s", $1}')

		if [ -z "$param_value" ]; then
			debugtype="info"
			syslogmessage="Failed to get current value of $param, mesh interface not established."
			write_to_syslog
			continue
		fi

		if [ "$param_value" != "$conf" ]; then
			debugtype="info"
			syslogmessage="Old value:$param=$param_value, Setting new value:$param=$conf"
			write_to_syslog
			iwstatus=$(iw dev $iface set mesh_param $param "$conf" 2>&1)

			if [ ! -z "$iwstatus" ]; then
				debugtype="err"
				syslogmessage="$param: $iwstatus"
				write_to_syslog
			fi
		fi
	done
}

restart_mesh () {
	mesh_gate_state
	wifi
	wait_for_mesh
}

get_current_setup () {
	debuglevel=$(uci get mesh11sd.setup.debuglevel 2> /dev/null)

	if [ -z "$debuglevel" ]; then
		debuglevel=1
	fi

	enabled=$(uci get mesh11sd.setup.enabled 2> /dev/null)

	if [ -z "$enabled" ]; then
		enabled=1
	fi

	syslogmessage="option enabled [ $enabled ]"
	debugtype="info"
	write_to_syslog

	#####
	syslogmessage="option debuglevel [ $debuglevel ]"
	debugtype="info"
	write_to_syslog

	#####
	checkinterval=$(uci get mesh11sd.setup.checkinterval 2> /dev/null)

	if [ -z "$checkinterval" ] || [ "$checkinterval" -lt 10 ]; then
		checkinterval=10
	fi

	syslogmessage="option checkinterval [ $checkinterval ]"
	debugtype="info"
	write_to_syslog

	#####
	portal_detect=$(uci get mesh11sd.setup.portal_detect 2> /dev/null)

	if [ -z "$portal_detect" ]; then
		portal_detect=1
	fi

	syslogmessage="option portal_detect [ $portal_detect ]"
	debugtype="info"
	write_to_syslog

	#####
	portal_channel=$(uci get mesh11sd.setup.portal_channel 2> /dev/null)

	if [ -z "$portal_channel" ]; then
		portal_channel="default"
	fi

	syslogmessage="option portal_channel [ $portal_channel ]"
	debugtype="info"
	write_to_syslog

	#####
	get_mesh_path_cost

	#####
	interface_timeout=$(uci get mesh11sd.setup.interface_timeout 2> /dev/null)

	if [ -z "$interface_timeout" ] || [ "$interface_timeout" -lt 10 ]; then
		interface_timeout=10
	fi

	syslogmessage="option interface_timeout [ $interface_timeout ]"
	debugtype="info"
	write_to_syslog

	#####
	auto_config=$(uci get mesh11sd.setup.auto_config 2> /dev/null)

	if [ -z "$auto_config" ] || [ "$auto_config" -gt 0 ]; then
		auto_config=1
	fi

	syslogmessage="option auto_config [ $auto_config ]"
	debugtype="info"
	write_to_syslog

	#####
	auto_mesh_id=$(uci get mesh11sd.setup.auto_mesh_id 2> /dev/null | awk '{printf "%s", $1}')

	if [ -z "$auto_mesh_id" ]; then
		auto_mesh_id="--__"
	fi

	auto_mesh_id=$(printf "$auto_mesh_id" | sha256sum | awk '{printf $1}' | tail -c55 | head -c30)

	syslogmessage="auto_mesh_id hash [ $auto_mesh_id ]"
	debugtype="info"
	write_to_syslog

	#####

	country=$(iw reg get | grep -w "country" | awk '{printf "%s", $2}')

	if [ "$country" = "00" ]; then
		syslogmessage="WARNING - country code not set - interoperability with other mesh nodes may be compromised or fail altogether...."
		debugtype="warn"
		write_to_syslog
	fi

	auto_mesh_band=$(uci get mesh11sd.setup.auto_mesh_band 2> /dev/null | awk '{printf "%s", $1}')

	if [ -z "$auto_mesh_band" ] && [ "$country" != "00" ]; then
		auto_mesh_band="2g40"
	fi

	bandlist="2g 5g 6g 60g"
	bandcheck=0

	for band in $bandlist; do

		if [ "$band" = "$auto_mesh_band" ]; then
			bandcheck=1
			break
		fi

	done

	if [ "$bandcheck" = 0 ]; then
		auto_mesh_band="2g40"
	fi

	syslogmessage="option auto_mesh_band [ $auto_mesh_band ]"
	debugtype="info"
	write_to_syslog

	#####
	auto_mesh_key=$(uci get mesh11sd.setup.auto_mesh_key 2> /dev/null | awk '{printf "%s", $1}')

	if [ -z "$auto_mesh_key" ]; then
		auto_mesh_key=$(echo "$auto_mesh_id""91b39a9b41e918e9bce1c8d5d7d3e071d6f1f8855a7c0214f687550177c5d5b8" | sha256sum | awk '{printf "%s", $1}')
	else
		auto_mesh_key=$(echo "$auto_mesh_id""$auto_mesh_key" | sha256sum | awk '{printf "%s", $1}')
	fi

	syslogmessage="option auto_mesh_key [ $auto_mesh_key ]"
	debugtype="info"
	write_to_syslog

	#####
	auto_mesh_network=$(uci get mesh11sd.setup.auto_mesh_network 2> /dev/null)

	if [ -z "$auto_mesh_network" ]; then
		auto_mesh_network="lan"
	fi

	# Block wan and wan6 as valid network zones for mesh

	if [ "$auto_mesh_network" = "wan" ] || [ "$auto_mesh_network" = "wan6" ]; then
		auto_mesh_network="lan"
	fi

	zone_status=$(uci show firewall | grep -w "name='$auto_mesh_network'" &>/dev/null ; echo $?)

	if [ "$zone_status" -eq 1 ]; then
		syslogmessage="network zone [ $auto_mesh_network ] does not exist"
		debugtype="warn"
		write_to_syslog
		auto_mesh_network="lan"
	else
		syslogmessage="option auto_mesh_network [ $auto_mesh_network ]"
		debugtype="info"
		write_to_syslog
	fi
	syslogmessage="option auto_mesh_network [ $auto_mesh_network ]"
	debugtype="info"
	write_to_syslog

	#####
	mesh_basename=$(uci get mesh11sd.setup.mesh_basename 2> /dev/null)

	if [ -z "$mesh_basename" ]; then
		mesh_basename="m-11s-"
	else
		#remove non alphanumeric
		mesh_basename=$(echo "$mesh_basename" | sed 's/[^a-zA-Z0-9]//g')
		#get first 4 chars
		mesh_basename="m-${mesh_basename:0:4}-"
		#convert to lower case
		mesh_basename=$(printf $mesh_basename | tr '[A-Z]' '[a-z]')
	fi

	syslogmessage="option mesh_basename [ $mesh_basename ]"
	debugtype="info"
	write_to_syslog

	#####
	mesh_gate_enable=$(uci get mesh11sd.setup.mesh_gate_enable 2> /dev/null)

	if [ -z "$mesh_gate_enable" ]; then
		mesh_gate_enable="1"
	fi

	syslogmessage="option mesh_gate_enable [ $mesh_gate_enable ]"
	debugtype="info"
	write_to_syslog

	#####
	ssid_suffix_enable=$(uci get mesh11sd.setup.ssid_suffix_enable 2> /dev/null)

	if [ -z "$ssid_suffix_enable" ]; then
		ssid_suffix_enable="1"
	fi

	syslogmessage="option ssid_suffix_enable [ $ssid_suffix_enable ]"
	debugtype="info"
	write_to_syslog
}

get_mesh_path_cost () {
	mesh_path_cost=$(uci get mesh11sd.setup.mesh_path_cost 2> /dev/null)

	if [ -z "$mesh_path_cost" ]; then
		mesh_path_cost="1"
	fi

	syslogmessage="option mesh_path_cost [ $mesh_path_cost ]"
	debugtype="info"
	write_to_syslog
}

wait_for_interface () {
	local ifname="$1"
	local timeout=$interface_timeout

	for i in $(seq $timeout); do
		if [ $(ip link show $ifname 2> /dev/null | grep -c -w "state UP") -eq 1 ]; then
			ifstatus="up"
			break
		fi
		sleep 1
		if [ $i == $timeout ] ; then
			syslogmessage="$ifname is not up - giving up for now."
			debugtype="notice"
			write_to_syslog
			ifstatus="down"
		fi
	done
}

# Write debug message to syslog
# $syslogmessage contains the string to log
# $debugtype contains the debug level string: debug, info, warn, notice, err, emerg.
write_to_syslog() {

	if [ "$mute" = 0 ]; then
		debuglevel=$(uci get mesh11sd.setup.debuglevel 2> /dev/null)

		if [ -z "$debuglevel" ]; then
			debuglevel=1
		fi

		if [ ! -z "$syslogmessage" ]; then

			case $debugtype in
				"emerg") debugnum=0;;
				"err") debugnum=0;;
				"notice") debugnum=1;;
				"warn") debugnum=1;;
				"info") debugnum=2;;
				"debug") debugnum=3;;
				*) debugnum=1; debugtype="notice";;
			esac

			if [ "$debuglevel" -ge "$debugnum" ]; then
				echo "$syslogmessage" | logger -p "daemon.$debugtype" -s -t "mesh11sd[$mesh11sdpid]"
			fi
		fi
	else
		mute=0
	fi
}

mesh_gate_state() {
	aplist=$(uci show wireless | grep "mode='ap'" | awk -F "." '{printf "%s ", $2}')

	for gate in $aplist; do

		if [ "$mesh_gate_enable" -eq 1 ]; then
			ucibatch="set wireless.$gate.disabled='0'"
			echo "$ucibatch" | uci batch
		else
			ucibatch="set wireless.$gate.disabled='1'"
			echo "$ucibatch" | uci batch
		fi
	done
}

check_gate() {
	is_gate=$(iw dev | grep -w "type AP")

	if [ -z "$is_gate" ]; then
		uci set mesh11sd.mesh_params.mesh_connected_to_gate='0'
	else
		uci set mesh11sd.mesh_params.mesh_connected_to_gate='1'
	fi
}

check_channel() {
	# Can we see the portal?
	link_to_portal=0

	# We need to scan for working channel if we cannot see a portal
	# Check for portal every checkinterval_multiplier checkintervals
	checkinterval_multiplier=6

	timenow=$(date +%s)

	debugtype="debug"
	syslogmessage="checking for working channel...."
	write_to_syslog

	if [ -z $cctimestamp ]; then
		cctimestamp=$(date +%s)
	fi

	elapsed_time=$(($timenow - $cctimestamp))
	mininterval=$(($checkinterval * $checkinterval_multiplier))

	if [ "$mininterval" -le "$elapsed_time" ]; then
		ifaces=$(uci export wireless | grep "config wifi-iface" | awk -F"'" '$2 != "" {printf "%s ",$2}')

		for iface in $ifaces; do
			ucibatch="get wireless.$iface.mode"
			mode=$(echo "$ucibatch" | uci batch)

			if [ "$mode" = "mesh" ]; then
				ucibatch="get wireless.$iface.network"
				network=$(echo "$ucibatch" | uci batch)
				ucibatch="get network.$network.device"
				device=$(echo "$ucibatch" | uci batch)

				if [ -e "/tmp/dhcp6probe" ]; then
					mv "/tmp/dhcp6probe" "/tmp/dhcp6probe.prev"
				fi

				odhcp6c -ev "$device" 2>/tmp/dhcp6probe &

				local retries=20

				for retry in $(seq $retries); do

					if [ -e "/tmp/dhcp6probe" ]; then
						sleep 4
						break
					else
						sleep 1
						continue
					fi
				done

				link_to_portal=$(cat /tmp/dhcp6probe | grep -q -w "Got a valid ADVERTISE" ; echo $?)
				instances=$(pgrep odhcp6c | awk '{printf "%s ", $1}')

				for instance in $instances; do
					kill "$instance"
				done

				debugtype="debug"

				if [ "$link_to_portal" -eq 0 ]; then
					syslogmessage="portal detected"
				else
					syslogmessage="portal not detected"
				fi

				write_to_syslog
				cctimestamp=""
				scan_channel
				continue
			fi
		done
	fi
}

scan_channel() {
	debugtype="debug"
	syslogmessage="Entering scan channel...."
	write_to_syslog

	if [ "$link_to_portal" -gt 0 ]; then
		# No link to portal. Maybe we are on the wrong channel, so scan for meshid to get channel
		meshconfigs=$(uci show wireless 2> /dev/null | grep "mode='mesh'" | awk -F ".mode='mesh'" '{printf "%s " $1}')

		if [ ! -z "$meshconfigs" ]; then

			for meshconfig in $meshconfigs; do
				ifname=$(uci get $meshconfig.ifname)
				our_channel=$(iw dev $ifname info | grep -w "channel" | awk -F " " '{printf "%s", $2}')
				mesh_id=$(uci get $meshconfig.mesh_id)
				scanned_channels=$(iw dev $ifname scan | grep -F -w -B 5 "MESH ID: $mesh_id" | awk -F "primary channel: " '$2 != "" {printf "%s ",$2}')

				if [ "$our_channel" -le 14 ]; then
					band="2g"
				else
					band=""
				fi

				for channel in $scanned_channels; do

					if [ "$channel" -gt 14 ] && [ "$band" = "2g" ]; then
						continue
					fi


					if [ "$channel" = "$our_channel" ]; then
						continue
					else
						device=$(uci get $meshconfig.device)
						ucibatch="set wireless.$device.channel='$channel'"
						echo "$ucibatch" | uci batch
						restart_mesh
						break
					fi
				done

				ucibatch=""
			done

		fi
	fi
}

get_portal_state() {
	debugtype="debug"
	syslogmessage="In get_portal_state. firstloop=$firstloop..."
	write_to_syslog

	if [ "$firstloop" -eq 1 ]; then
		local retries=10

		for retry in $(seq $retries); do
			default_gw=$(ip route | grep "default via")

			if [ -z "$default_gw" ]; then
				debugtype="debug"
				syslogmessage="In Startup - portal upstream link check - iteration [ $retry ] ...."
				write_to_syslog
				sleep 1
				continue
			fi
		done

	else
		default_gw=$(ip route | grep "default via")
	fi


	debugtype="debug"
	syslogmessage="default_gw=$default_gw...."
	write_to_syslog

	authoritative=$(uci get dhcp.@dnsmasq[0].authoritative 2>/dev/null | awk '{printf "%d", $1}')

	if [ -z "$default_gw" ]; then
		is_portal=""
		wan_ip=""
		gw_ip=""
	else
		gw_ip=$(echo "$default_gw" | awk -F" " '{printf "%s", $3}')
		wan_ip=$(echo "$default_gw" | awk -F" " '{printf "%s", $7}')

		# must test if upstream gateway is actually up
		gwstatus=$(ping -q -c 1 -W 1 192.168.8.1 &> /dev/null; echo $?)

		if [ "$gwstatus" -eq 0 ]; then
			is_portal=$(ip addr | grep "$wan_ip")
		else
			is_portal=""
		fi
	fi

	debugtype="debug"
	syslogmessage="leaving get_portal_state - is_portal=$is_portal. wan_ip=$wan_ip. gw_ip=$gw_ip.."
	write_to_syslog

}

check_portal() {
	is_portal=""
	debugtype="debug"
	syslogmessage="Entering check portal.... $auto_mesh_network"
	write_to_syslog

	if [ "$enabled" -eq 1 ]; then
		get_portal_state

		if [ -z "$is_portal" ]; then
			# This IS NOT a layer 3 mesh portal
			uci set mesh11sd.mesh_params.mesh_connected_to_as='0'

			if [ "$authoritative" -eq 1 ] || [ -z "$authoritative" ]; then
				debugtype="debug"
				syslogmessage="This meshnode is NOT a portal"
				write_to_syslog

				uci set dhcp.@dnsmasq[0].authoritative='0'
				echo "set dhcp.$auto_mesh_network.ignore='1'" | uci batch
				echo "set dhcp.$auto_mesh_network.ra_default='2'" | uci batch
				echo "set dhcp.$auto_mesh_network.dhcpv6='disabled'" | uci batch
				echo "set dhcp.$auto_mesh_network.ra='disabled'" | uci batch
				uci set dhcp.@dnsmasq[0].quietdhcp='1'
				/sbin/service dnsmasq restart
				/sbin/service odhcpd restart

			fi

			check_channel

		else
			# This IS a layer 3 mesh portal
			uci set mesh11sd.mesh_params.mesh_connected_to_as='1'

			if [ -z "$authoritative" ] || [ "$authoritative" -eq 0 ]; then
				debugtype="debug"
				syslogmessage="This meshnode is an upstream portal"
				write_to_syslog

				uci set dhcp.@dnsmasq[0].authoritative='1'
				echo "set dhcp.$auto_mesh_network.ignore='0'" | uci batch
				echo "set dhcp.$auto_mesh_network.ra_default='2'" | uci batch
				echo "set dhcp.$auto_mesh_network.dhcpv6='server'" | uci batch
				echo "set dhcp.$auto_mesh_network.ra='server'" | uci batch
				uci set dhcp.@dnsmasq[0].quietdhcp='1'
				/sbin/service dnsmasq restart
				/sbin/service odhcpd restart
			fi
		fi
	fi

	debugtype="debug"
	syslogmessage="Leaving check portal...."
	write_to_syslog

}

wait_for_nodes() {
	local tics=4

	echo " If the node you are looking for is not in the list - re-run this command."
	echo
	echo -n " Waiting for node list to build "

	for tic in $(seq $tics); do
		echo -n "* "
		sleep 1
	done

	echo
}

wait_for_mesh() {
	get_mesh_iflist

	local retries=20

	for iface in $iflist; do

		for retry in $(seq $retries); do
			wait_for_interface "$iface"

			if [ "$ifstatus" = "down" ]; then
				sleep 1
				continue
			fi
		done

		if [ "$ifstatus" = "down" ] && [ "$fixup1" -ne 1 ]; then
			fixup1=1
			debugtype="err"
			syslogmessage="Attempting fixup: Mesh interface $iface failed - Possible wireless driver bug.... Attempting fixup"
			write_to_syslog
			uci_section_name=$(uci show wireless | grep "ifname='$iface'" | awk -F "." '{printf "%s", $2}')
			radio=$(uci show wireless | grep "$uci_section_name" | grep "device=" | awk -F "'" '{printf "%s", $2}')
			wifiifaces=$(uci show wireless | grep "device='$radio'" | awk -F "." '{printf "%s ", $2}')

			for wifiiface in $wifiifaces; do

				if [ "$wifiiface" = "$uci_section_name" ]; then
					continue
				else
					debugtype="notice"
					syslogmessage="Attempting fixup: Disabling mesh gate for this node"
					write_to_syslog
					sleep 1
					echo "set wireless.$wifiiface.disabled='1'" | uci batch
					wifi
				fi
			done
		fi
	done
}

ccpy_setup() {
	ndp_scan_peer
	get_mesh_iflist

	for iface in $iflist; do
		wait_for_interface "$iface"

		if [ "$ifstatus" = "down" ]; then
			continue
		fi

		peers=$(iw dev $iface mpath dump | grep -c -w $iface)
		macrouting=$(iw dev $iface mpath dump | awk -F" " 'NR>1 {printf "%s/%s ",$1,$2}')

		for peer in $macrouting; do
			peermac=$(echo "$peer" | awk -F"/" '{printf "%s", $1}')
			peerlist="$peerlist ""$peermac"
		done
	done

	meshconfigs=$(uci show wireless 2> /dev/null | grep "mode='mesh'" | awk -F ".mode='mesh'" '{printf "%s " $1}')
	connectlist=""

	if [ ! -z "$meshconfigs" ]; then
		for meshconfig in $meshconfigs; do
			networks=$(uci get $meshconfig.network)

			for network in $networks; do
				device=$(uci get network.$network.device)

				if [ "$network" != "$network_previous" ]; then
					connectlist="$connectlist ""$(ip -6 neigh | grep "fe80::" | grep "$device" | grep "lladdr" | grep "router"| awk '{printf "%s%s%s,%s ", $1, "%", $3, $5}')"
				fi

				network_previous=$network
			done

			# Stop after the first mesh network - there should only be one but more might have been added in error
			break
		done
	fi
}

ndp_scan_peer() {
	# NDP - Send linklocal multicast
	if [ -e "/tmp/devicemac" ]; then
		. /tmp/devicemac
		response=$(ping -q -c 2 -I "$device" "ff02::1" &>/dev/null)
	fi
}

get_wiphys() {
	# get list of physical wireless interfaces and reverse the list order
	wiphys=$(iw list | grep -w "Wiphy" | awk -F "Wiphy " '{printf "%s ", $2}' | awk '{ for (i = NF; i > 0; i = i - 1) printf("%s ", $i) }')
}

refresh_bridgemac() {
	# get the device device mac and write it to /tmp/devicemac
	device=$(uci get network.$auto_mesh_network.device)
	wait_for_interface "$device"
	devicemac=$(ip link | grep -A 1 "$device:" | grep -w "link/ether" | awk '{printf "%s", $2}')
	echo "device=\"$device\" ; devicemac=\"$devicemac\"" > /tmp/devicemac
}

auto_config() {
	debugtype="debug"
	syslogmessage="Entering auto config...."
	write_to_syslog
	autoconfig=0

	if [ "$autoconfig" -eq 0 ]; then
		# do we have a mesh supporting wpad?
		installed_wpad=$(opkg list-installed | grep "wpad" | awk '{printf "%s", $1}' | awk -F "-" '{print $2}')

		if [ "$installed_wpad" = "mesh" ] || [ "$installed_wpad" = "mbedtls" ] || [ "$installed_wpad" = "wolfssl" ] || [ "$installed_wpad" = "openssl" ]; then

			refresh_bridgemac
			. /tmp/devicemac
			get_wiphys

			if [ ! -z "$wiphys" ]; then
				for wiphy in $wiphys; do
					mesh_capable=$(iw phy $wiphy info | grep -A 15 "Supported interface modes:" | grep -w "mesh point")

					if [ -z "$mesh_capable" ]; then
						continue
					fi

					# Prerequisites met so we can autoconfigure
					phyindex=$(echo "$wiphy" | awk -F "phy" '{printf "%s", $2}')

					phyindex=$(printf "%x" $phyindex)
					mesh_ifname="$mesh_basename""$phyindex"


					echo "set wireless.m11s$phyindex=wifi-iface" | uci batch
					echo "set wireless.m11s$phyindex.device='radio$phyindex'" | uci batch
					echo "set wireless.m11s$phyindex.mode='mesh'" | uci batch
					echo "set wireless.m11s$phyindex.encryption='sae'" | uci batch
					echo "set wireless.m11s$phyindex.mesh_id='$auto_mesh_id'" | uci batch
					echo "set wireless.m11s$phyindex.key='$auto_mesh_key'" | uci batch
					echo "set wireless.m11s$phyindex.network='$auto_mesh_network'" | uci batch
					echo "set wireless.m11s$phyindex.ifname='$mesh_ifname'" | uci batch
					echo "set wireless.radio$phyindex.disabled='0'" | uci batch

					band=$(uci get wireless.radio$phyindex.band | awk '{printf "%s", $1}')

					if [ "$auto_mesh_band" = "2g40" ]; then
						mesh_band="2g"
					else
						mesh_band=$auto_mesh_band
					fi

					if [ "$band" = "$mesh_band" ]; then
						echo "set wireless.m11s$phyindex.disabled='0'" | uci batch
					else
						echo "set wireless.m11s$phyindex.disabled='1'" | uci batch
					fi

					if [ "$mesh_band" = "2g" ] || [ "$mesh_band" = "2g40" ]; then
						get_portal_state

						if [ "$auto_mesh_band" = "2g40" ]; then
							echo "set wireless.radio$phyindex.noscan='1'" | uci batch
							echo "set wireless.radio$phyindex.htmode='HT40'" | uci batch
						fi

						if [ ! -z "$is_portal" ] || [ "$portal_detect" -eq 0 ]; then

							if [ "$portal_channel" = "auto" ] && [ "$band" = "2g" ]; then

								for i in $(seq 9 1 64); do
									#choose start point of sequence away from end eg "9"
									chan=$((0x$(printf "$devicemac" | sha256sum | awk '{printf $1}' | tail -c$i | head -c1)))

									#Check for max
									if [ "$chan" -gt 11 ]; then
										continue
									fi

									#Check for min
									if [ "$chan" -le 0 ]; then
										continue
									fi

									echo "set wireless.radio$phyindex.channel='$chan'" | uci batch
									break
								done

							elif [ "$portal_channel" != "auto" ] && [ "$portal_channel" != "default" ] && [ "$band" = "2g" ]; then
								chan="$portal_channel"

								#Check for max
								if [ "$chan" -gt 11 ]; then
									chan=11
								fi

								#Check for min
								if [ "$chan" -le 0 ]; then
									chan=1
								fi

								echo "set wireless.radio$phyindex.channel='$chan'" | uci batch
							fi
						fi
					fi
				done

				#Add suffix to ssid
				if [ "$ssid_suffix_enable" -eq 1 ]; then
					aplist=$(uci show wireless 2> /dev/null | grep "='ap'" | awk -F "." '{printf "%s.%s ", $1, $2}')
					suffix=$(echo $devicemac | awk -F":" '{printf "%s%s", $5, $6}')

					for ap in $aplist; do
						ssid=$(uci get "$ap.ssid" 2> /dev/null | awk '{printf "%s", $1}')
						echo "set $ap.ssid='$ssid-$suffix'" | uci batch
					done

					echo "set system.@system[0].hostname='meshnode-$suffix'" | uci batch
					/sbin/service system restart
				fi

				debugtype="debug"
				syslogmessage="auto config complete...."
				write_to_syslog

				# set changed flag to signify a mesh restart is needed
				changed=1

			else
				debugtype="err"
				syslogmessage="Unable to autoconfigure. No physical wireless interfaces found"
				write_to_syslog
			fi
		else
			debugtype="err"
			syslogmessage="Unable to autoconfigure. Please install package wpad-mesh-mbedtls, wpad-mesh-wolfssl, wpad-mesh-openssl or an equivalent full version"
			write_to_syslog
		fi

		# TODO If we want to call auto_config from cli then we can stop it happening more than once by uncommenting the following:
		#autoconfig=1
	fi
}

urlencode() {
	entitylist="
		s/%/%25/g
		s/\s/%20/g
		s/\"/%22/g
		s/:/%3A/g
		s/>/%3E/g
		s/</%3C/g
		s/'/%27/g
		s/\`/%60/g
	"
	local buffer="$1"

	for entity in $entitylist; do
		urlencoded=$(echo "$buffer" | sed "$entity")
		buffer=$urlencoded
	done

	urlencoded=$(echo "$buffer" | awk '{ gsub(/\$/, "\\%24"); print }')
}

urldecode() {
	entitylist="
		s/%22/\"/g
		s/%3A/:/g
		s/%3E/>/g
		s/%3C/</g
		s/%27/'/g
		s/%60/\`/g
		s/%25/%/g
	"
	local buffer="$1"

	for entity in $entitylist; do
		urldecoded=$(echo "$buffer" | sed "$entity")
		buffer=$urldecoded
	done

	buffer=$(echo "$buffer" | awk '{ gsub(/%24/, "$"); print }')
	urldecoded=$(echo "$buffer" | awk '{ gsub(/%20/, " "); print }')
}

##############
# Start point
##############

mesh11sdpid=$(pgrep -f "/bin/sh /usr/sbin/mesh11sd")
get_current_setup 2> /dev/null

if [ -z "$1" ] || [ "$1" = "-h" ] || [ $1 = "--help" ] || [ $1 = "help" ]; then
	echo "
  Usage: mesh11sd [option] [argument...]]

  Option: -h --help help
  Returns: This help information

  Option: -v --version version
  Returns: The mesh11sd version

  Option: debuglevel
  Argument: 0 - silent, 1 - notice, 2 - info, 3 - debug
  Returns: The mesh11sd debug level

  Option: enable
  Returns: \"1\" and exit code 0 if successful, exit code 1 if was already enabled

  Option: disable
  Returns: \"0\" and exit code 0 if successful, exit code 1 if was already disabled

  Option: status
  Returns: the mesh status in json format

  Option: connect
  Connect a remote terminal session on a remote meshnode
  Usage: mesh11sd connect [remote_meshnode_macaddress]
    If the remote meshnode mac address is omitted, a list of meshnode mac addresses available for connection is listed

  Option: copy
  Copy a file to /tmp on a remote meshnode
  Usage: mesh11sd copy [remote_meshnode_macaddress] [path_of_source_file]
    If the remote meshnode mac address is null, or both arguments are omitted, a list of meshnode mac addresses available for copy is listed

  For further documentation, see: https://github.com/openNDS/mesh11sd#readme

"

elif [ "$1" = "-v" ] || [ $1 = "--version" ] || [ $1 = "version" ]; then
	echo "mesh11sd version $version"

elif [ "$1" = "debuglevel" ]; then

	if [ -z "$2" ];then
		echo "$debuglevel"
	else

		if [ "$2" -ge 0 ] && [ "$2" -le 3 ]; then
			ucibatch="set mesh11sd.setup.debuglevel='$2'"
			echo "$ucibatch" | uci batch
			echo "$2"
		else
			echo "Invalid debuglevel requested"
		fi
	fi

elif [ "$1" = "enable" ]; then

	if [ "$enabled" -eq 1 ]; then
		echo "1"
		exit 1
	else
		ucibatch="set mesh11sd.setup.enabled='1'"
		echo "$ucibatch" | uci batch
		echo "1"
		exit 0
	fi

elif [ "$1" = "disable" ]; then

	if [ "$enabled" -eq 0 ]; then
		echo "0"
		exit 1
	else
		ucibatch="set mesh11sd.setup.enabled='0'"
		echo "$ucibatch" | uci batch
		echo "0"
		exit 0
	fi

elif [ "$1" = "status" ]; then
	# get list of interfaces
	get_mesh_iflist

	if [ -e "/tmp/devicemac" ]; then
		. /tmp/devicemac
	fi

	procd_status=$(/etc/init.d/mesh11sd status)

	echo "{"
	echo "  \"setup\":{"
	echo "    \"version\":\"$version\","
	echo "    \"enabled\":\"$enabled\","
	echo "    \"procd_status\":\"$procd_status\","
	echo "    \"portal_detect\":\"$portal_detect\","
	echo "    \"portal_channel\":\"$portal_channel\","
	echo "    \"mesh_basename\":\"$mesh_basename\","
	echo "    \"auto_config\":\"$auto_config\","
	echo "    \"auto_mesh_network\":\"$auto_mesh_network\","
	echo "    \"auto_mesh_band\":\"$auto_mesh_band\","
	echo "    \"auto_mesh_id\":\"$auto_mesh_id\","
	echo "    \"mesh_gate_enable\":\"$mesh_gate_enable\","
	echo "    \"mesh_path_cost\":\"$mesh_path_cost\","
	echo "    \"checkinterval\":\"$checkinterval\","
	echo "    \"interface_timeout\":\"$interface_timeout\","
	echo "    \"debuglevel\":\"$debuglevel\""
	echo "  }"
	echo "  \"interfaces\":{"

	for iface in $iflist; do
		wait_for_interface "$iface"

		if [ "$ifstatus" = "down" ]; then
			continue
		fi

		# get list of mesh parameters for this interface
		get_params

		if [ -z "$params" ]; then
			# this is not a mesh interface
			continue
		else
			params=$(echo "$params" | awk -F" " '{printf "      \"%s\":\"%s\",\n", $1, $3}')
			echo "    \"$iface\":{"
			echo "$params"

			meshconfig=$(uci show wireless | grep "ifname='$iface'" | awk -F ".ifname='$iface'" '{printf "%s", $1}')

			if [ -z "$meshconfig" ]; then
				echo "      \"interface\":\"unmanaged\""
				echo "    }"
			else
				device=$(uci get $meshconfig.device 2> /dev/null)
				channel=$(uci show wireless | grep "$device.channel" | awk -F "'" '{printf "%s", $2}')
				meshid=$(uci get $meshconfig.mesh_id 2> /dev/null)

				echo "      \"mesh_id\":\"$meshid\","
				echo "      \"device\":\"$device\","
				echo "      \"channel\":\"$channel\","

				tx_packets=$(devstatus $iface 2>/dev/null | grep "tx_packets" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"tx_packets\":\"$tx_packets\","

				tx_bytes=$(devstatus $iface 2>/dev/null | grep "tx_bytes" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"tx_bytes\":\"$tx_bytes\","

				rx_packets=$(devstatus $iface 2>/dev/null | grep "rx_packets" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"rx_packets\":\"$rx_packets\","

				rx_bytes=$(devstatus $iface 2>/dev/null | grep "rx_bytes" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"rx_bytes\":\"$rx_bytes\","

				peernum=0
				peers=$(iw dev $iface mpath dump 2>/dev/null | grep -c -w $iface)
				macrouting=$(iw dev $iface mpath dump 2>/dev/null | awk -F" " 'NR>1 {printf "%s/%s ",$1,$2}')
				peer_macs="$devicemac ""$(iw dev m-11s-0 mpath dump 2>/dev/null | awk -F" " 'NR>1 {printf "%s ",$1}')"

				echo "      \"this_node\":\"$devicemac\","
				echo "      \"active_peers\":\"$peers\","
				echo "      \"peers\":{"

				for peer in $macrouting; do
					peernum=$((peernum+1))
					peermac=$(echo "$peer" | awk -F"/" '{printf "%s", $1}')
					echo "        \"$peermac\":{"
					next_hop=$(echo "$peer" | awk -F"/" '{printf "%s", $2}')
					echo "          \"next_hop\":\"$next_hop\""

					if [ "$peers" = "$peernum" ]; then
						echo "        }"
					else
						echo "        },"
					fi
				done
				echo "      }"

				ap_ifaces=$(iw dev | grep -B 7 "type AP"| grep "Interface" | awk '{printf "%s ", $2}')

				for ap_iface in $ap_ifaces; do
					ap_sta=$(iw dev $ap_iface station dump | grep "Station" | awk  '{printf "%s ", $2}')
					ap_stas="$ap_stas""$ap_sta"
				done

				for ap_sta in $ap_stas; do
					starouting="$starouting""$ap_sta/$devicemac "
				done

				stanum=0
				realstanum=0
				stations=0
				starouting="$starouting"$(iw dev $iface mpp dump | awk -F" " 'NR>1 {printf "%s/%s ",$1,$2}')
				stas=$(iw dev $iface mpp dump | awk -F" " 'NR>1 {printf "%s ",$1}')
				stas="$ap_stas""$stas"

				for sta in $stas; do
					sta=$(printf "%s" "$sta" | awk -F ":" '{printf "%s:%s:%s:%s:%s", $2, $3, $4, $5, $6}')
					inpeermacs=$(echo "$peer_macs" | grep "$sta")

					if [ "$inpeermacs" = "$peer_macs" ]; then
						continue
					else
						stations=$((stations+1))
					fi
				done

				echo "      \"active_stations\":\"$stations\","
				echo "      \"stations\":{"

				for staroute in $starouting; do
					sta="${staroute%/*}"
					inpeermacs=$(echo "$peer_macs" | grep "$sta")

					if [ "$inpeermacs" = "$peer_macs" ]; then
						continue
					fi

					stanum=$((stanum+1))
					stamac=$(echo "$sta" | awk -F"/" '{printf "%s", $1}')
					proxy_node=$(echo "$sta" | awk -F"/" '{printf "%s", $2}')
					proxy_node="${staroute##*/}"

					stamacid=$(printf "%s" "$stamac" | awk -F ":" '{printf "%s%s%s%s%s", $2, $3, $4, $5, $6}')
					proxy_nodeid=$(printf "%s" "$proxy_node" | awk -F ":" '{printf "%s%s%s%s%s", $2, $3, $4, $5, $6}')

					if [ "$stamacid" = "$proxy_nodeid" ]; then
						continue
					fi

					realstanum=$((realstanum+1))
					echo "        \"$stamac\":{"
					echo "          \"proxy_node\":\"$proxy_node\""

					if [ "$stations" = "$stanum" ]; then
						echo "        }"
					else
						echo "        },"
					fi

				done
				echo "      }"
				echo "    }"
			fi
		fi
	done

	echo "  }"
	echo "}"

elif [ "$1" = "connect" ]; then

	if [ "$auto_config" -eq 0 ]; then
		echo "======================================================================"
		echo "Unable to connect -  enable auto_config to connect to other meshnodes"
		echo "======================================================================"
		exit 1
	fi

	nodeaddr=$(printf "%s" "$2" | tr "-" ":" | tr "[A-Z]" "[a-z]")

	echo "========================================================="
	ccpy_setup

	if [ -z "$nodeaddr" ]; then
		echo " Connect a remote terminal session on a remote meshnode"
		echo "    Usage: mesh11sd connect [remote_meshnode_macaddress]"
		echo
		wait_for_nodes
		echo
		echo " The following meshnodes are available for remote connection:"
	fi

	if [ ! -z "$peerlist" ]; then

		for connectto in $connectlist; do
			linklocal="${connectto%,*}"
			ndpmac="${connectto##*,}"
			ndpmacf=$(printf "%s" "$ndpmac" | tr ":" "-")
			ip6addr=$(echo "$linklocal" | awk -F "%" '{printf "%s", $1}')

			if [ -z "$nodeaddr" ]; then
				echo "	$ndpmacf	[ ip address: $ip6addr ]"
			elif [ ! -z "$nodeaddr" ]; then

				if [ "$nodeaddr" = "$ndpmac" ]; then
					echo
					echo "Trying to connect to meshnode \"$ndpmacf\"....."
					echo
					ssh "root@$linklocal"
					echo
					echo "Disconnected from meshnode \"$ndpmacf\""
					echo
					break
				fi
			fi
		done
	fi

	echo "========================================================="
	echo

	exit 0

elif [ "$1" = "copy" ]; then

	if [ "$auto_config" -eq 0 ]; then
		echo "================================================================"
		echo "Unable to copy -  enable auto_config to copy to other meshnodes"
		echo "================================================================"
		exit 1
	fi
	nodeaddr=$(printf "%s" "$2" | tr "-" ":" | tr "[A-Z]" "[a-z]")
	filepath=$3
	filename=$(echo "$filepath" | awk -F "/" '{printf $NF}')
	echo "========================================================="
	ccpy_setup

	if [ -z "$nodeaddr" ]; then
		echo " Copy a file to /tmp on a remote meshnode"
		echo "    Usage: mesh11sd copy [remote_meshnode_macaddress] [path_of_source_file]"
		echo
		wait_for_nodes
		echo
		echo " The following meshnodes are available for remote copy:"

	fi

	if [ ! -z "$peerlist" ]; then
		for connectto in $connectlist; do
			linklocal="${connectto%,*}"
			ndpmac="${connectto##*,}"
			ndpmacf=$(printf "%s" "$ndpmac" | tr ":" "-")

			if [ -z "$nodeaddr" ]; then
				echo "	$ndpmacf"
			elif [ "$nodeaddr" = "$ndpmac" ]; then

				if [ ! -z "$filepath" ]; then
					echo
					echo "Trying to copy to meshnode \"$ndpmacf\"....."
					echo
					scp "$filepath" "root@[$linklocal]:/tmp/$filename"
					echo
					echo "Disconnected from meshnode \"$ndpmacf\""
					echo
					break
				fi
			fi
		done
	fi

	echo "========================================================="
	echo

	exit 0

elif [ "$1" = "daemon" ]; then
	uci revert mesh11sd
	uci revert wireless
	uci revert dhcp
	debugtype="notice"
	syslogmessage="mesh11sd is in startup"
	write_to_syslog

	#Default flags
	startup=4 # bit 2
	statusmode=2 # bit 1
	enabled=1 #bit 0

	# Initial conditions
	statusmode=0
	changed=0
	firstloop=1
	autoconfig=0
	macfixup=0
	mute=0
	uci delete dhcp.@dnsmasq[0].authoritative 2>/dev/null

	# Initial Mode Flag
	mode=$(($startup + $statusmode + $enabled ))
	lastmode=0

	# Start the main loop
	while true; do

		#get_current_setup
		mode=$(($startup + $statusmode + $enabled))

		syslogmessage=""

		if [ $mode -eq 5 ]; then
			# startup=4, statusmode=0, enabled=1
			startup=0
			statusmode=0
			mode=1
			syslogmessage="mesh11sd v$version has started: mesh management mode $mode"

		elif [ $mode -eq 4 ]; then
			# startup=4, statusmode=0, enabled=0
			startup=0
			statusmode=2
			mode=0
			syslogmessage="mesh11sd v$version has started: mesh status mode $mode"

		elif [ $mode -eq 3 ]; then
			# startup=0, statusmode=2, enabled=1
			startup=0
			statusmode=0
			mode=1
			syslogmessage="mesh11sd v$version has started: mesh management mode $mode"

		elif [ $mode -eq 2 ]; then
			# startup=0, statusmode=2, enabled=0
			startup=0
			statusmode=2
			mode=0
			syslogmessage="mesh11sd v$version has started: mesh status mode $mode"

		elif [ $mode -eq 1 ]; then
			# startup=0, statusmode=0, enabled=1
			startup=0
			statusmode=0
			mode=1
			syslogmessage="mesh11sd v$version has started, mesh management mode $mode"

		elif [ $mode -eq 0 ]; then
			# startup=0, statusmode=0, enabled=0
			startup=0
			statusmode=2
			mode=0
			syslogmessage="mesh11sd v$version has started: mesh status mode $mode"
		fi

		if [ $mode -ne $lastmode ]; then
			debugtype="notice"
			write_to_syslog
		fi

		lastmode=$mode
		meshindex=0
		meshconfigs=""

		if [ "$enabled" = 1 ]; then
			#get list of mesh configs
			meshconfigs=$(uci show wireless 2> /dev/null | grep "mode='mesh'" | awk -F ".mode='mesh'" '{printf "%s " $1}')

			if [ -z "$meshconfigs" ]; then
				# no mesh configuration yet
				debugtype="info"
				syslogmessage="No mesh interfaces detected yet.... Attempting auto configure"
				write_to_syslog

				############# Autoconfig

				if [ "$auto_config" -eq 1 ]; then
					auto_config
				else
					debugtype="err"
					syslogmessage="auto_config is disabled. Please configure a mesh interface or enable auto_config...."
					write_to_syslog
					sleep $checkinterval

					auto_config=$(uci get mesh11sd.setup.auto_config 2> /dev/null)

					if [ -z "$auto_config" ] || [ "$auto_config" -gt 0 ]; then
						auto_config=1
					fi

					syslogmessage="option auto_config [ $auto_config ]"
					debugtype="info"
					write_to_syslog

				fi

				########################
			fi

			# Is the list of meshconfigs still empty?
			if [ -z "$meshconfigs" ]; then
				meshconfigs=$(uci show wireless 2> /dev/null | grep "mode='mesh'" | awk -F ".mode='mesh'" '{printf "%s " $1}')
			fi

			if [ ! -z "$meshconfigs" ]; then
				# we have an existing mesh config

				for meshconfig in $meshconfigs; do

					if [ $meshindex -gt 15 ]; then
						# Max number of mesh interfaces exceeded - abort
						debugtype="warn"
						syslogmessage="Maximum number of mesh interfaces exceeded"
						write_to_syslog
						break
					fi

					meshindex=$(($meshindex+1))
				done

				# set mesh mac address for this meshconfig
				refresh_bridgemac
				. /tmp/devicemac
				get_wiphys

				#### Disable macfixup:
				# macfixup=1

				if [ "$macfixup" -eq 0 ]; then
					for wiphy in $wiphys; do
						# Create a probe interface
						wifi down
						iw phy "$wiphy" interface add probe type mesh mesh_id "probe"
						# Get the probe mac address
						meshmac=$(iw dev | grep -A 5 "Interface probe" | grep -w "addr" | awk '{printf "%s", $2}')
						# Delete the probe interface
						iw dev "probe" del

						if [ "$meshmac" != "$devicemac" ]; then

							ucimeshconfig=$(uci get $meshconfig.macaddr 2> /dev/null)

							if [ -z "$ucimeshconfig" ]; then
								# No mac address fixup, so add one
								phyindex=$(echo "$wiphy" | awk -F "phy" '{printf "%s", $2}')
								phyindex=$(printf "%x" $phyindex)
								mesh_ifname="$mesh_basename""$phyindex"
								debugtype="notice"
								syslogmessage="Setting mac address of mesh interface $mesh_ifname to [ $devicemac ]"
								write_to_syslog

								ucibatch="set wireless.m11s$phyindex.macaddr='$devicemac'"
								echo "$ucibatch" | uci batch
								changed=1
							fi
						fi
					done

					macfixup=1
				fi
			else
				continue
			fi

			if [ "$firstloop" -eq 1 ] || [ "$changed" -eq 1 ]; then
				firstloop=0
				changed=0
				restart_mesh
			fi
			# get a list of interfaces
			get_mesh_iflist

			# Make sure STP is on
			stpstatus=$(brctl show $device | grep "yes" | awk '{printf "%s", $3}')

			if [ -z "$stpstatus" ] || [ "$stpstatus" != "yes" ]; then
				brctl stp "$device" yes
			fi

			for iface in $iflist; do
				wait_for_interface "$iface"

				if [ "$ifstatus" = "down" ]; then
					continue
				fi

				debugtype="debug"
				syslogmessage="interface $iface is $ifstatus"
				write_to_syslog

				# get list of mesh parameters for this interface
				get_params

				if [ -z "$params" ]; then
					# this is not a mesh interface
					continue
				else
					# Check if this interface has a uci ifname
					uciname=$(uci show wireless | grep "ifname='$iface'" | awk -F "." '{printf "wireless.%s" $2}')

					if [ -z "$uciname" ]; then
						# Error - No interface name in config, we should have added one
						debugtype="err"
						syslogmessage="Error getting mesh interface name"
						write_to_syslog
						continue
					fi
				fi

				# Set stp path cost
				mute=1
				get_mesh_path_cost
				brctl setpathcost "$device" "$iface" "$mesh_path_cost"

				br_ifaces=$(brctl showstp "$device" | grep -B 1 -w "port id" | grep "(" | awk '{printf "%s ", $1}')

				for br_iface in $br_ifaces; do

					if [ "$br_iface" = "$iface" ]; then
						continue
					fi

					other_path_cost=$(( 65535 - $mesh_path_cost))
					brctl setpathcost "$device" "$br_iface" "$other_path_cost"

				done

				#Do NOT configure parameters found in wireless config
				# so change the value of uciname before calling check_mesh_params.
				#
				#Override wireless config and/or set parameters to those found in mesh11sd config
				uciname="mesh11sd.mesh_params"
				check_mesh_params
				check_mesh_phantom
			done

			if [ "$portal_detect" -eq 1 ]; then
				check_portal
			else
				# portal_detect is not enabled - force portal mode:
				authoritative=$(uci get dhcp.@dnsmasq[0].authoritative 2>/dev/null | awk '{printf "%d", $1}')

				if [ -z "$authoritative" ]; then
					authoritative=0
				fi

				uci set mesh11sd.mesh_params.mesh_connected_to_as='1'

				if [ "$authoritative" -eq 0 ] || [ -z "$authoritative" ]; then
					debugtype="notice"
					syslogmessage="Portal detection is disabled, forcing portal mode"
					write_to_syslog

					uci set dhcp.@dnsmasq[0].authoritative='1'
					echo "set dhcp.$auto_mesh_network.ignore='0'" | uci batch
					echo "set dhcp.$auto_mesh_network.ra_default='2'" | uci batch
					echo "set dhcp.$auto_mesh_network.dhcpv6='server'" | uci batch
					echo "set dhcp.$auto_mesh_network.ra='server'" | uci batch
					uci set dhcp.@dnsmasq[0].quietdhcp='1'
					/sbin/service dnsmasq restart
					/sbin/service odhcpd restart
				fi
			fi

			check_gate
		fi

		debugtype="debug"
		syslogmessage="checkinterval $checkinterval seconds"
		write_to_syslog

		sleep $checkinterval
	done
	exit 0

else
	echo "Unrecognised command - For help, try mesh11sd --help "
fi
