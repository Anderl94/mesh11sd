#!/bin/sh
#Copyright (C) BlueWave Projects and Services 2015-2023
#This software is released under the GNU GPL license.
#
# mesh11sd daemon
#
version="2.1.0beta"

get_mesh_iflist () {
	iflist=""
	all_ifcs=$(iw dev | awk -F "Interface " '$2>0{printf "%s " $2}')

	for iface in $all_ifcs; do
		iftype=$(iw dev $iface info | grep "type" | awk '{printf "%s", $2}')

		if [ "$iftype" = "mesh" ]; then
			iflist="$iflist $iface"
		fi
	done
}

check_mesh_phantom () {
	nodelist=$(iw dev $iface mpath dump | awk '{printf "%s,%s ", $1, $2}')

	debugtype="debug"
	syslogmessage="nodelist [$nodelist]"
	write_to_syslog

	for node in $nodelist; do
		phantom=$(echo "$node" | awk -F"," '$2 == "00:00:00:00:00:00" {printf $1 }')

		if [ ! -z "$phantom" ]; then
			debugtype="warn"
			syslogmessage="Phantom meshnode detected [$phantom] - deleting"
			write_to_syslog
			iw dev $iface mpath del $phantom
		fi
	done
}

get_params () {
	params=$(iw dev $iface mesh_param dump 2> /dev/null)

	if [ "$?" != 0 ]; then
		buffer="/tmp/"$(date | sha256sum | awk '{printf $1}')
		param_list=$(iw dev $iface get mesh_param 2> /dev/null | grep " - " | awk -F" - " '{printf "%s ", $2}')
		params=""


		for param in $param_list; do
			paramval=$(iw dev $iface get mesh_param $param 2> /dev/null)
			if [ "$?" = 0 ]; then
				paramline="$param = $paramval"
				echo "$paramline" >> $buffer
			fi
		done



		if [ -e "$buffer" ]; then
			params=$(cat $buffer)
			rm "$buffer"
		fi
	fi
}

check_mesh_params () {

	for param in $params; do

		conf=$(uci get $uciname.$param 2> /dev/null)

		if [ -z "$conf" ]; then
			continue
		fi

		param_value=$(iw dev $iface get mesh_param $param | awk '{printf "%s", $1}')

		if [ -z "$param_value" ]; then
			debugtype="info"
			syslogmessage="Failed to get current value of $param, mesh interface not established."
			write_to_syslog
			continue
		fi

		if [ "$param_value" != "$conf" ]; then
			debugtype="info"
			syslogmessage="Old value:$param=$param_value, Setting new value:$param=$conf"
			write_to_syslog
			iwstatus=$(iw dev $iface set mesh_param $param "$conf" 2>&1)

			if [ ! -z "$iwstatus" ]; then
				debugtype="err"
				syslogmessage="$param: $iwstatus"
				write_to_syslog
			fi
		fi
	done
}

restart_mesh () {
	wifi
}

get_current_setup () {
	enabled=$(uci get mesh11sd.setup.enabled 2> /dev/null)

	if [ -z "$enabled" ]; then
		enabled=1
	fi

	debuglevel=$(uci get mesh11sd.setup.debuglevel 2> /dev/null)

	if [ -z "$debuglevel" ]; then
		debuglevel=1
	fi

	checkinterval=$(uci get mesh11sd.setup.checkinterval 2> /dev/null)

	if [ -z "$checkinterval" ] || [ "$checkinterval" -lt 10 ]; then
		checkinterval=10
	fi

	portal_detect=$(uci get mesh11sd.setup.portal_detect 2> /dev/null)

	if [ -z "$portal_detect" ]; then
		portal_detect=1
	fi

	interface_timeout=$(uci get mesh11sd.setup.interface_timeout 2> /dev/null)

	if [ -z "$interface_timeout" ] || [ "$interface_timeout" -lt 10 ]; then
		interface_timeout=10
	fi

	mesh_basename=$(uci get mesh11sd.setup.mesh_basename 2> /dev/null)

	if [ -z "$mesh_basename" ]; then
		mesh_basename="m-11s-"
	else
		#remove non alphanumeric
		mesh_basename=$(echo "$mesh_basename" | sed 's/[^a-zA-Z0-9]//g')
		#get first 4 chars
		mesh_basename="m-${mesh_basename:0:4}-"
		#convert to lower case
		mesh_basename=$(printf $mesh_basename | tr '[A-Z]' '[a-z]')
	fi
}

wait_for_interface () {
	local ifname="$1"
	local timeout=$interface_timeout

	for i in $(seq $timeout); do
		if [ $(ip link show $ifname 2> /dev/null | grep -c -w "state UP") -eq 1 ]; then
			ifstatus="up"
			break
		fi
		sleep 1
		if [ $i == $timeout ] ; then
			syslogmessage="$ifname is not up - giving up for now."
			debugtype="notice"
			write_to_syslog
			ifstatus="down"
		fi
	done
}

# Write debug message to syslog
# $syslogmessage contains the string to log
# $debugtype contains the debug level string: debug, info, warn, notice, err, emerg.
write_to_syslog() {

	if [ ! -z "$syslogmessage" ]; then

		case $debugtype in
			"emerg") debugnum=0;;
			"err") debugnum=0;;
			"notice") debugnum=1;;
			"warn") debugnum=1;;
			"info") debugnum=2;;
			"debug") debugnum=3;;
			*) debugnum=1; debugtype="notice";;
		esac

		if [ "$debuglevel" -ge "$debugnum" ]; then
			echo "$syslogmessage" | logger -p "daemon.$debugtype" -s -t "mesh11sd[$mesh11sdpid]"
		fi
	fi
}

check_gate() {
	is_gate=$(iw dev | grep -w "type AP")

	if [ -z "$is_gate" ]; then
		uci set mesh11sd.mesh_params.mesh_connected_to_gate='0'
	else
		uci set mesh11sd.mesh_params.mesh_connected_to_gate='1'
	fi
}

check_channel() {
	# Can we see the portal?
	link_to_portal=0
	timenow=$(date +%s)

	if [ -z $cctimestamp ]; then
		cctimestamp=$(date +%s)
	fi

	elapsed_time=$(($timenow - $cctimestamp))
	mininterval=$(($checkinterval * 5))

	if [ "$mininterval" -le "$elapsed_time" ]; then
		ifaces=$(uci export wireless | grep "config wifi-iface" | awk -F"'" '$2 != "" {printf "%s ",$2}')

		for iface in $ifaces; do
			ucibatch="get wireless.$iface.mode"
			mode=$(echo "$ucibatch" | uci batch)

			if [ "$mode" = "mesh" ]; then
				ucibatch="get wireless.$iface.network"
				network=$(echo "$ucibatch" | uci batch)
				ucibatch="get network.$network.device"
				device=$(echo "$ucibatch" | uci batch)

				echo "device=$device!" >> /tmp/time

				#udhcpc -R -t 10 -T 5 -A 4 -q -n -i $device &> /dev/null
				udhcpc -R -t 10 -T 5 -A 4 -q -n -i $device
				link_to_portal=$?
				cctimestamp=""
				scan_channel
				continue
			fi
		done
	fi
}

scan_channel() {
	if [ "$link_to_portal" -gt 0 ]; then
		# No link to portal. Maybe we are on the wrong channel, so scan for meshid to get channel
		meshconfigs=$(uci show wireless 2> /dev/null | grep "mode='mesh'" | awk -F ".mode='mesh'" '{printf "%s " $1}')

		if [ ! -z "$meshconfigs" ]; then

			for meshconfig in $meshconfigs; do
				ifname=$(uci get $meshconfig.ifname)
				our_channel=$(iw dev $ifname info | grep -w "channel" | awk -F " " '{printf "%s", $2}')
				mesh_id=$(uci get $meshconfig.mesh_id)
				scanned_channels=$(iw dev $ifname scan | grep -F -w -B 5 "MESH ID: $mesh_id" | awk -F "primary channel: " '$2 != "" {printf "%s ",$2}')

				if [ "$our_channel" -le 14 ]; then
					band="2g"
				else
					band=""
				fi

				for channel in $scanned_channels; do

					if [ "$channel" -gt 14 ] && [ "$band" = "2g" ]; then
						continue
					fi


					if [ "$channel" = "$our_channel" ]; then
						continue
					else
						device=$(uci get $meshconfig.device)
						ucibatch="set wireless.$device.channel='$channel'"
						echo "$ucibatch" | uci batch
						restart_mesh
						break
					fi
				done

				ucibatch=""
			done

		fi
	fi
}

check_portal() {
	if [ "$enabled" -eq 1 ]; then
		proto=$(uci get network.lan.proto)
		default_gw=$(ip route | grep "default via")
		authoritative=$(uci get dhcp.@dnsmasq[0].authoritative)

		if [ -z "$default_gw" ]; then
			is_portal=""
		else
			gw_ip=$(echo "$default_gw" | awk -F" " '{printf "%s", $3}')
			wan_ip=$(echo "$default_gw" | awk -F" " '{printf "%s", $7}')
			is_portal=$(ip addr | grep "$wan_ip")
		fi

		if [ -z "$is_portal" ]; then
			# This IS NOT a layer 3 mesh portal
			uci set mesh11sd.mesh_params.mesh_connected_to_as='0'

			if [ "$authoritative" -eq 1 ]; then
				debugtype="debug"
				syslogmessage="This meshnode is NOT a portal"
				write_to_syslog

				uci set dhcp.@dnsmasq[0].authoritative='0'
				uci set dhcp.lan.ignore='1'
				uci set dhcp.lan.ra_default='2'
				/etc/init.d/dnsmasq restart
			fi

			check_channel

		else
			# This IS a layer 3 mesh portal
			uci set mesh11sd.mesh_params.mesh_connected_to_as='1'

			if [ "$authoritative" -eq 0 ]; then
				debugtype="debug"
				syslogmessage="This meshnode is an upstream portal"
				write_to_syslog

				uci set dhcp.@dnsmasq[0].authoritative='1'
				uci set dhcp.lan.ignore='0'
				uci set dhcp.lan.ra_default='2'
				/etc/init.d/dnsmasq restart
			fi
		fi
	fi
}

wait_for_mesh() {
	get_mesh_iflist

	for iface in $iflist; do
		wait_for_interface "$iface"
	done
}

ccpy_setup() {
	get_mesh_iflist

	for iface in $iflist; do
		wait_for_interface "$iface"

		if [ "$ifstatus" = "down" ]; then
			continue
		fi

		peers=$(iw dev $iface mpath dump | grep -c -w $iface)
		macrouting=$(iw dev $iface mpath dump | awk -F" " 'NR>1 {printf "%s/%s ",$1,$2}')

		for peer in $macrouting; do
			peermac=$(echo "$peer" | awk -F"/" '{printf "%s", $1}')
			peerlist="$peerlist ""$peermac"
		done
	done

	meshconfigs=$(uci show wireless 2> /dev/null | grep "mode='mesh'" | awk -F ".mode='mesh'" '{printf "%s " $1}')
	connectlist=""

	if [ ! -z "$meshconfigs" ]; then
		for meshconfig in $meshconfigs; do
			networks=$(uci get $meshconfig.network)

			for network in $networks; do
				device=$(uci get network.$network.device)

				if [ "$network" != "$network_previous" ]; then

					for peer in $peerlist; do
						known=$(ip neigh | grep "$peer")

						if [ -z "$known" ]; then
							ndp_scan_peer
						fi
					done

					connectlist="$connectlist ""$(ip -6 neigh | grep "fe80::" | grep "$device" | awk '{printf "%s%s%s,%s ", $1, "%", $3, $5}')"
				fi

				network_previous=$network
			done

			# Stop after the first network - there should only be one but Luci can add more in error
			break

		done
	fi
}

ndp_scan_peer() {
	# scan for peer
	peerlinklocal=$(echo $peer | awk -F":" '{printf "fe80::%s%s:%sff:fe%s:%s%s", $1, $2, $3, $4, $5, $6}')

	pingresult=$(ping -q -W 1 -c 1 -I $device $peerlinklocal &>/dev/null)
	retval=$?

	if [ "$retval" -gt 0 ]; then
		echo "	$peer is not yet available"
	fi
}

##############
# Start point
##############

mesh11sdpid=$(pgrep -f "/bin/sh /usr/sbin/mesh11sd")
get_current_setup

if [ -z "$1" ] || [ "$1" = "-h" ] || [ $1 = "--help" ] || [ $1 = "help" ]; then
	echo "
  Usage: mesh11sd [option] [argument...]]

  Option: -h --help help
  Returns: This help information

  Option: -v --version version
  Returns: The mesh11sd version

  Option: debuglevel
  Argument: 0 - silent, 1 - notice, 2 - info, 3 - debug
  Returns: The mesh11sd debug level

  Option: enable
  Returns: \"1\" and exit code 0 if successful, exit code 1 if was already enabled

  Option: disable
  Returns: \"0\" and exit code 0 if successful, exit code 1 if was already disabled

  Option: status
  Returns: the mesh status in json format

  Option: connect
  Connect a remote terminal session on a remote meshnode
  Usage: mesh11sd connect [remote_meshnode_macaddress]
    If the remote meshnode mac address is omitted, a list of meshnode mac addresses available for connection is listed

  Option: copy
  Copy a file to a remote meshnode
  Usage: mesh11sd copy [remote_meshnode_macaddress] [path_of_source_file]
    If the remote meshnode mac address is null, or both arguments are omitted, a list of meshnode mac addresses available for copy is listed

  For further documentation, see: https://github.com/openNDS/mesh11sd#readme

"

elif [ "$1" = "-v" ] || [ $1 = "--version" ] || [ $1 = "version" ]; then
	echo "mesh11sd version $version"

elif [ "$1" = "debuglevel" ]; then

	if [ -z "$2" ];then
		echo "$debuglevel"
	else

		if [ "$2" -ge 0 ] && [ "$2" -le 3 ]; then
			ucibatch="set mesh11sd.setup.debuglevel='$2'"
			echo "$ucibatch" | uci batch
			echo "$2"
		else
			echo "Invalid debuglevel requested"
		fi
	fi

elif [ "$1" = "enable" ]; then

	if [ "$enabled" -eq 1 ]; then
		echo "1"
		exit 1
	else
		ucibatch="set mesh11sd.setup.enabled='1'"
		echo "$ucibatch" | uci batch
		echo "1"
		exit 0
	fi

elif [ "$1" = "disable" ]; then

	if [ "$enabled" -eq 0 ]; then
		echo "0"
		exit 1
	else
		ucibatch="set mesh11sd.setup.enabled='0'"
		echo "$ucibatch" | uci batch
		echo "0"
		exit 0
	fi

elif [ "$1" = "status" ]; then
	# get list of interfaces
	get_mesh_iflist
	procd_status=$(/etc/init.d/mesh11sd status)

	echo "{"
	echo "  \"setup\":{"
	echo "    \"version\":\"$version\","
	echo "    \"enabled\":\"$enabled\","
	echo "    \"procd_status\":\"$procd_status\","
	echo "    \"portal_detect\":\"$portal_detect\","
	echo "    \"mesh_basename\":\"$mesh_basename\","
	echo "    \"checkinterval\":\"$checkinterval\","
	echo "    \"interface_timeout\":\"$interface_timeout\","
	echo "    \"debuglevel\":\"$debuglevel\""
	echo "  }"
	echo "  \"interfaces\":{"

	for iface in $iflist; do
		wait_for_interface "$iface"

		if [ "$ifstatus" = "down" ]; then
			continue
		fi

		# get list of mesh parameters for this interface
		get_params

		if [ -z "$params" ]; then
			# this is not a mesh interface
			continue
		else
			params=$(echo "$params" | awk -F" " '{printf "      \"%s\":\"%s\",\n", $1, $3}')
			echo "    \"$iface\":{"
			echo "$params"

			meshconfig=$(uci show wireless | grep "ifname='$iface'" | awk -F ".ifname='$iface'" '{printf "%s", $1}')

			if [ -z "$meshconfig" ]; then
				echo "      \"interface\":\"unmanaged\""
				echo "    }"
			else
				device=$(uci get $meshconfig.device 2> /dev/null)
				channel=$(uci show wireless | grep "$device.channel" | awk -F "'" '{printf "%s", $2}')
				meshid=$(uci get $meshconfig.mesh_id 2> /dev/null)

				echo "      \"mesh_id\":\"$meshid\","
				echo "      \"device\":\"$device\","
				echo "      \"channel\":\"$channel\","

				tx_packets=$(devstatus $iface | grep "tx_packets" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"tx_packets\":\"$tx_packets\","

				tx_bytes=$(devstatus $iface | grep "tx_bytes" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"tx_bytes\":\"$tx_bytes\","

				rx_packets=$(devstatus $iface | grep "rx_packets" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"rx_packets\":\"$rx_packets\","

				rx_bytes=$(devstatus $iface | grep "rx_bytes" | awk -F": " '{print $2}' | tr -d ",")
				echo "      \"rx_bytes\":\"$rx_bytes\","

				peernum=0
				peers=$(iw dev $iface mpath dump | grep -c -w $iface)
				macrouting=$(iw dev $iface mpath dump | awk -F" " 'NR>1 {printf "%s/%s ",$1,$2}')
				peer_macs=$(iw dev m-11s-0 mpath dump | awk -F" " 'NR>1 {printf "%s ",$1}')

				echo "      \"active_peers\":\"$peers\","
				echo "      \"peers\":{"

				for peer in $macrouting; do
					peernum=$((peernum+1))
					peermac=$(echo "$peer" | awk -F"/" '{printf "%s", $1}')
					echo "        \"$peermac\":{"
					next_hop=$(echo "$peer" | awk -F"/" '{printf "%s", $2}')
					echo "          \"next_hop\":\"$next_hop\""

					if [ "$peers" = "$peernum" ]; then
						echo "        }"
					else
						echo "        },"
					fi
				done
				echo "      }"

				stanum=0
				stations=0
				starouting=$(iw dev $iface mpp dump | awk -F" " 'NR>1 {printf "%s/%s ",$1,$2}')
				stas=$(iw dev $iface mpp dump | awk -F" " 'NR>1 {printf "%s ",$1}')

				for sta in $stas; do

					inpeermacs=$(echo "$peer_macs" | grep "$sta")

					if [ "$inpeermacs" = "$peer_macs" ]; then
						continue
					else
						stations=$((stations+1))
					fi
				done

				echo "      \"active_stations\":\"$stations\","
				echo "      \"stations\":{"

				for staroute in $starouting; do
					sta="${staroute%/*}"
					inpeermacs=$(echo "$peer_macs" | grep "$sta")

					if [ "$inpeermacs" = "$peer_macs" ]; then
						continue
					fi

					stanum=$((stanum+1))
					stamac=$(echo "$sta" | awk -F"/" '{printf "%s", $1}')
					proxy_node=$(echo "$sta" | awk -F"/" '{printf "%s", $2}')
					proxy_node="${staroute##*/}"

					echo "        \"$stamac\":{"
					echo "          \"proxy_node\":\"$proxy_node\""

					if [ "$stations" = "$stanum" ]; then
						echo "        }"
					else
						echo "        },"
					fi

				done
				echo "      }"
				echo "    }"
			fi
		fi
	done

	echo "  }"
	echo "}"

elif [ "$1" = "connect" ]; then
	nodeaddr=$2

	ccpy_setup

	if [ -z "$nodeaddr" ]; then
		echo "========================================================="
		echo "The following meshnodes are available for remote connection:"
		echo
	fi

	if [ ! -z "$peerlist" ]; then

		for connectto in $connectlist; do
			linklocal="${connectto%,*}"
			ndpmac="${connectto##*,}"

			for peer in $peerlist; do

				if [ "$peer" = "$ndpmac" ]; then
					meshnodemac="$peer"
					found=1
					break
				else
					found=0
				fi
			done

			if [ -z "$nodeaddr" ] && [ "$found" -eq 1 ]; then
				echo "	$meshnodemac"
			elif [ ! -z "$nodeaddr" ] && [ "$found" -eq 1 ]; then

				if [ "$nodeaddr" = "$meshnodemac" ]; then
					echo
					echo "Trying to connect to meshnode \"$meshnodemac\"....."
					echo
					ssh "root@$linklocal"
					echo
					echo "Disconnected from meshnode \"$meshnodemac\""
					echo
					break
				fi
			fi
		done
	fi

	echo "========================================================="
	echo

	exit 0

elif [ "$1" = "copy" ]; then
	nodeaddr=$2
	filepath=$3
	filename=$(echo "$filepath" | awk -F "/" '{printf $NF}')

	ccpy_setup

	if [ -z "$nodeaddr" ]; then
		echo "========================================================="
		echo "The following meshnodes are available for remote copy:"
		echo
	fi

	if [ ! -z "$peerlist" ]; then
		for connectto in $connectlist; do
			linklocal="${connectto%,*}"
			ndpmac="${connectto##*,}"

			for peer in $peerlist; do
				if [ "$peer" = "$ndpmac" ]; then
					meshnodemac="$peer"
					found=1
					break
				else
					found=0
				fi
			done

			if [ -z "$nodeaddr" ] && [ "$found" -eq 1 ]; then
				echo "	$meshnodemac"
			elif [ ! -z "$nodeaddr" ] && [ "$found" -eq 1 ]; then

				if [ "$nodeaddr" = "$meshnodemac" ]; then

					if [ ! -z "$filepath" ]; then
						echo
						echo "Trying to copy to meshnode \"$meshnodemac\"....."
						echo
						scp "$filepath" "root@[$linklocal]:/tmp/$filename"
						echo
						echo "Disconnected from meshnode \"$meshnodemac\""
						echo
						break
					fi
				fi
			fi
		done
	fi

	echo "========================================================="
	echo

	exit 0

elif [ "$1" = "daemon" ]; then
	uci revert mesh11sd
	uci revert wireless
	uci revert dhcp
	debugtype="notice"
	syslogmessage="mesh11sd is in startup"
	write_to_syslog

	#Default flags
	startup=4 # bit 2
	statusmode=2 # bit 1
	enabled=1 #bit 0

	# Initial conditions
	statusmode=0
	changed=0
	firstloop=1

	# Initial Mode Flag
	mode=$(($startup + $statusmode + $enabled ))
	lastmode=0

	# Wait one checkinterval before starting the main loop
	sleep $checkinterval

	while true; do

		get_current_setup
		mode=$(($startup + $statusmode + $enabled))

		syslogmessage=""

		if [ $mode -eq 5 ]; then
			# startup=4, statusmode=0, enabled=1
			startup=0
			statusmode=0
			mode=1
			syslogmessage="mesh11sd v$version has started: mesh management mode $mode"

		elif [ $mode -eq 4 ]; then
			# startup=4, statusmode=0, enabled=0
			startup=0
			statusmode=2
			mode=0
			syslogmessage="mesh11sd v$version has started: mesh status mode $mode"

		elif [ $mode -eq 3 ]; then
			# startup=0, statusmode=2, enabled=1
			startup=0
			statusmode=0
			mode=1
			syslogmessage="mesh11sd v$version has started: mesh management mode $mode"

		elif [ $mode -eq 2 ]; then
			# startup=0, statusmode=2, enabled=0
			startup=0
			statusmode=2
			mode=0
			syslogmessage="mesh11sd v$version has started: mesh status mode $mode"

		elif [ $mode -eq 1 ]; then
			# startup=0, statusmode=0, enabled=1
			startup=0
			statusmode=0
			mode=1
			syslogmessage="mesh11sd v$version has started, mesh management mode $mode"

		elif [ $mode -eq 0 ]; then
			# startup=0, statusmode=0, enabled=0
			startup=0
			statusmode=2
			mode=0
			syslogmessage="mesh11sd v$version has started: mesh status mode $mode"
		fi

		if [ $mode -ne $lastmode ]; then
			debugtype="notice"
			write_to_syslog
		fi

		lastmode=$mode
		meshindex=0

		if [ "$enabled" = 1 ]; then
			#get list of mesh configs
			meshconfigs=$(uci show wireless 2> /dev/null | grep "mode='mesh'" | awk -F ".mode='mesh'" '{printf "%s " $1}')

			if [ ! -z "$meshconfigs" ]; then
				for meshconfig in $meshconfigs; do

					if [ $meshindex -gt 15 ]; then
						# Max number of mesh interfaces exceeded - abort
						debugtype="warn"
						syslogmessage="Maximum number of mesh interfaces exceeded"
						write_to_syslog
						break
					fi

					hexmeshindex=$(printf "%x" $meshindex)
					ifname=$(uci get $meshconfig.ifname 2> /dev/null)
					mesh_ifname="$mesh_basename""$hexmeshindex"

					if [ -z "$ifname" ] || [ "$ifname" != "$mesh_ifname" ]; then
						# No interface name in config, so add one
						ucibatch="set $meshconfig.ifname='$mesh_ifname'"
						echo "$ucibatch" | uci batch
						changed=1
						debugtype="notice"
						syslogmessage="Setting mesh interface name to [ $mesh_ifname ]"
						write_to_syslog
					fi

					meshindex=$(($meshindex+1))
				done

				if [ "$changed" -eq 1 ] || [ "$firstloop" -eq 1 ]; then
					changed=0
					firstloop=0
					sleep $checkinterval
					restart_mesh
					continue
				fi

				# get a list of interfaces
				get_mesh_iflist

				for iface in $iflist; do
					wait_for_interface "$iface"

					if [ "$ifstatus" = "down" ]; then
						continue
					fi

					debugtype="debug"
					syslogmessage="interface $iface is $ifstatus"
					write_to_syslog

					# get list of mesh parameters for this interface
					get_params

					if [ -z "$params" ]; then
						# this is not a mesh interface
						continue
					else
						# Check if this interface has a uci ifname
						uciname=$(uci show wireless | grep "ifname='$iface'" | awk -F "." '{printf "wireless.%s" $2}')

						if [ -z "$uciname" ]; then
							# Error - No interface name in config, we should have added one
							debugtype="err"
							syslogmessage="Error getting mesh interface name"
							write_to_syslog
							continue
						fi
					fi

					#Do NOT configure parameters found in wireless config
					# so change the value of uciname before calling check_mesh_params.
					#
					#Override wireless config and/or set parameters to those found in mesh11sd config
					uciname="mesh11sd.mesh_params"
					check_mesh_params
					check_mesh_phantom
				done
			else
				debugtype="info"
				syslogmessage="No mesh interfaces detected yet...."
				write_to_syslog
			fi
		fi

		if [ "$firstloop" -eq 1 ]; then
			firstloop=0
			restart_mesh
		fi

		if [ "$portal_detect" -eq 1 ]; then
			check_portal
		else
			# portal_detect is not enabled - force portal mode:
			authoritative=$(uci get dhcp.@dnsmasq[0].authoritative)
			uci set mesh11sd.mesh_params.mesh_connected_to_as='1'

			if [ "$authoritative" -eq 0 ]; then
				debugtype="notice"
				syslogmessage="Portal detection is disabled, forcing portal mode"
				write_to_syslog

				uci set dhcp.@dnsmasq[0].authoritative='1'
				uci set dhcp.lan.ignore='0'
				uci set dhcp.lan.ra_default='2'
				/etc/init.d/dnsmasq restart
			fi
		fi

		check_gate
		sleep $checkinterval
	done

	exit 0

else
	echo "Unrecognised command - For help, try mesh11sd --help "
fi
